# identify와 code 란

`id` : 테이블에서 각 레코드를 고유하게 식별하기 위한 Primary key를 말한다.  
`code` : 레코드를 식별하기 위한 방법중 하나로 외부에서 의미를 가지는 어떤 식별자를 말한다. 사람이 인식할 수 있는 값일 수도 있고 어떤 도메인에서 특정 의미를 가지는 경우도 있다.

# 차이점

## 양의 정수(id)로 인덱스 관리

- 고유성 : id는 각 레코드마다 고유한 값을 가지므로 각 행을 명확히 식별한다.
- 성능 : 정수는 숫자이므로 인덱스를 생성하고 관리하는데 효율적이다. 대규모 데이터셋에서 정수 기반 인덱스를 crud 연산을 매우 빠르게 수행한다.
- 자동증가 : auto_increment(mysql) 또는 serial(postgresql)과 같은 기능을 통해 추가 코드 작성없이 고유성을 보장받을 수 있다.
- 일관성 : id는 내부적으로만 사용되고, 외부적으로는 의미가 없는 값이므로 데이터베이스 구조 변화에 영향을 받지 않는다.

## 문자열(code)로 인덱스 관리

- 의미있는 값 : code는 사람이 이해가능한 의미를 가지므로 외부 시스템 또는 외부 사용자와 상호작용에 유리하다. 국가코드, 우편번호, 상품코드 등 이런 code는 이해하기 쉽다.
- 고정된 값 : 외부 표준에 따라 정해진 값이거나 시스템 내에서 절대로 변경되지 않는 값
- 외부 참조 : 외부 시스템에서 공통 식별자로 사용될 수 있으므로 외부 시스템과 연동할 시 코드 이해가 쉬워진다.

## code의 단점

1. 데이터 크기

   - 숫자 인덱스 : 숫자는 데이터베이스에서 일반적으로 4바이트~8바이트의 크기를 가지며 이런 고정된 크기는 메모리 사용을 최적화하고 인덱스 검색시 일정한 속돌르 유지하는데 도움을 준다.
   - 문자 인덱스 : 문자열은 가변 길이 데이터 타입이며 길이에 따라 데이터 크기가 달라지며 길이가 길어질수록 메모리 사용이 늘어난다.

2. 비교 작업의 복잡성

   - 숫자 비교 : 숫자는 단순 크기 비교이므로 1번의 연산으로 충분하다.
   - 문자 비교 : 문자 비교는 사전식(lexicographical) 순서로 이루어지며, 문자열의 각 문자를 순차적으로 비교해야한다. 따라서 문자열 길이가 길어질수록 비교에 필요한 연산이 많아지게 된다.(line과 lion 비교시 두번째 문자까지 차이가 안나서 3번째 문자까지 비교 필요함)

3. 인덱스 크기 및 관리(캐시 사용시에도 비슷)
   - 숫자 인덱스 : 숫자 인덱스는 데이터 크기가 작교 비교가 간단해서 관리가 편하고 메모리에 올렸을때도 적은 공간을 차지한다.
   - 문자 인덱스 : 크기가 가변적이라 인덱스 크기가 커질 수 있어서 디스크에서 더 많은 공간을 차지하고 메모리 적재시에도 많은 공간을 차지한다.

## code를 사용하는 이유

code의 단점을 봤으니 사용하는 이유도 알아보자.

1. join 간소화 : code를 사용하면 테이블 간의 join에서 FK 제약 조건이 없으므로 복잡한 join을 피할 수 있다.
2. 빠른 조회 : code가 정해진 고정된 값이고 인덱스를 설정했다면, 대규모 데이터셋에서 FK 제약 조건으로 인해 cascade로 인한 성능 저하의 영향을 피할 수 있다.
3. 관리의 편리성 : 데이터베이스의 FK 제약 조건 대신 어플리케이션 레벨에서 무결성을 관리함으로써 편리함을 느낄 수 있다.

## FK 란

FK 제약 조건은 데이터베이스에서 한 테이블의 열이 다른 테이블의 특정 열과 관계를 맺고 있음을 보장하는 역할을 한다.

- 참조된 데이터 존재 여부 확인: 자식 테이블에 데이터가 삽입되거나 업데이트될 때, 참조된 부모 테이블에 해당 데이터가 존재하는지 확인한다.
- 연쇄적인 삭제 및 업데이트: 부모 테이블의 데이터를 삭제하거나 업데이트할 때, 자식 테이블의 관련 데이터를 함께 삭제하거나 업데이트할 수 있다.

## code로 FK 설정한다면 같은 문제가 발생하지 않는가?

논리적인 키로만 code를 사용 : code를 FK로 사용하지 않고 단지 인덱스를 설정해 논리적인 키로만 관리한다면, 데이터베이스에서 참조 무결성을 강제하지않으므로 대규모 데이터셋에서 cascade 등으로 인한 성능 저하를 피할 수 있다는 것이다.

참조 무결성을 애플리케이션 레벨에서 관리하며 데이터베이스 차원에서는 code를 단순 인덱스된 문자열 필드로 처리함으로써 추가적인 오버헤드를 피하는 것이다.

```
// 기존
CREATE TABLE country (
  id INT PRIMARY KEY,
  name VARCHAR(100),
);
```

```
// code로 사용
CREATE TABLE country (
  name VARCHAR(100),
  code VARCHAR(10)
);

CREATE INDEX idx_country_code ON country(code);
```
